---
AWSTemplateFormatVersion: '2010-09-09'

Parameters: 
  MyTableName: 
    Description: 'DynamoDB Table Name'
    Type: String
    Default: 'MyDynamoDBTable'


Resources:
  MyTopicRule:
    Type: AWS::IoT::TopicRule
    Properties:
      RuleName: MyIoTRule
      TopicRulePayload:
        RuleDisabled: 'false'
        Sql: SELECT * FROM 'esp8266/pub'
        Actions:
        - DynamoDBv2:
            PutItem: 
              TableName: 
                Ref: MyTableName
            RoleArn: !GetAtt MyIoT2DynamoDBRole.Arn

  MyIoT2DynamoDBRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: MyIoT2DynamoDBRole
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: iot.amazonaws.com
            Action: sts:AssumeRole
      Path: '/'
      Policies:
        - PolicyName: 'MyDynamoDBPolicy'
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: 'Allow'
                Action:
                  - 'dynamodb:PutItem'
                Resource: !GetAtt MyDynamoDBTable.Arn
  
  MyDynamoDBTable:
    Type: AWS::DynamoDB::Table
    Properties: 
      AttributeDefinitions: 
        - 
          AttributeName: "measurement"
          AttributeType: "S"
        - 
          AttributeName: "timestamp"
          AttributeType: "N"
      TableName: 
        Ref: MyTableName
      KeySchema: 
        - 
          AttributeName: "measurement"
          KeyType: "HASH"
        - 
          AttributeName: "timestamp"
          KeyType: "RANGE"
      BillingMode: "PAY_PER_REQUEST"

  QueryDynamoDB:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Code:
        ZipFile: !Sub |
          import json
          import boto3
          from boto3.dynamodb.conditions import Key


          dynamodb = boto3.resource('dynamodb')
          table = dynamodb.Table('myTable')


          def lambda_handler(event, context):

              if event["httpMethod"] == "POST":
                  req = json.loads(event['body'])
              elif event["httpMethod"] == "GET":
                  req = event["queryStringParameters"]
              elif event["httpMethod"] == "OPTIONS":
                  return {
                  'statusCode': 200,
                  'headers': {
                      'Content-Type': 'application/json',
                      'Access-Control-Allow-Origin': '*',
                      'Access-Control-Allow-Headers': 'Content-Type',
                      'Access-Control-Allow-Methods': 'OPTIONS,POST,GET'
                      },
                  }

              response1 = table.query(
                  KeyConditionExpression=Key('measurement').eq('temperature') & Key('timestamp').between(int(req['from']), int(req['to']))
              )
              response2 = table.query(
                  KeyConditionExpression=Key('measurement').eq('humidity') & Key('timestamp').between(int(req['from']), int(req['to']))
              )

              timestamp_t = [int(item['timestamp']) for item in response1['Items']]
              temperature = [float(item['value']) for item in response1['Items']] 
              timestamp_h = [int(item['timestamp']) for item in response2['Items']]
              humidity = [float(item['value']) for item in response2['Items']]
              timestamp = list(set(timestamp_t + timestamp_h))

              data = []
              for t in sorted(timestamp):
                  if t in timestamp_t:
                      temp = temperature[timestamp_t.index(t)]
                  else:
                      temp = None
                  if t in timestamp_h:
                      hum = humidity[timestamp_h.index(t)]
                  else:
                      hum = None
                  data.append([t, temp, hum])

              return {
                  'statusCode': 200,
                  'body': json.dumps({
                      'data': data
                      }),
                  'headers': {
                      'Content-Type': 'application/json',
                      'Access-Control-Allow-Origin': '*',
                      'Access-Control-Allow-Headers': 'Content-Type',
                      'Access-Control-Allow-Methods': 'OPTIONS,POST,GET'
                  },
              }
      Runtime: python3.8
      Environment:
        Variables:
          DYNAMODB_TABLE:
            Ref: MyTableName

  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - lambda.amazonaws.com
          Action:
          - sts:AssumeRole
      Path: "/"
      Policies:
        - PolicyName: AWSLambdaBasicExecutionRole
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
            - Effect: Allow
              Action:
              - logs:CreateLogGroup
              - logs:CreateLogStream
              - logs:PutLogEvents
              Resource: '*'
        - PolicyName: DynamoDBAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
            - Effect: Allow
              Action:
              - dynamodb:Query 
              Resource: !GetAtt MyDynamoDBTable.Arn
  
  ApiGatewayRestApi:
    Type: AWS::ApiGateway::RestApi
    Properties:
      ApiKeySourceType: HEADER
      Description: An API Gateway with a Lambda Integration
      Name: MyRestAPI

  ApiGatewayResource:
    Type: 'AWS::ApiGateway::Resource'
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ParentId: !GetAtt ApiGatewayRestApi.RootResourceId
      PathPart: '{proxy+}'

  ApiGatewayMethod:
    Type: 'AWS::ApiGateway::Method'
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResource
      HttpMethod: ANY
      AuthorizationType: NONE
      Integration:
        Credentials: !GetAtt ApiGatewayIamRole.Arn
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub >-
          arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${QueryDynamoDB.Arn}/invocations

  ApiGatewayModel:
    Type: AWS::ApiGateway::Model
    Properties:
      ContentType: 'application/json'
      RestApiId: !Ref ApiGatewayRestApi
      Schema: {}

  ApiGatewayStage:
    Type: AWS::ApiGateway::Stage
    Properties:
      DeploymentId: !Ref ApiGatewayDeployment
      Description: Lambda API Stage
      RestApiId: !Ref ApiGatewayRestApi
      StageName: 'prod'

  ApiGatewayDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn: ApiGatewayMethod
    Properties:
      Description: Lambda API Deployment
      RestApiId: !Ref ApiGatewayRestApi

  ApiGatewayIamRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: ''
            Effect: 'Allow'
            Principal:
              Service:
                - 'apigateway.amazonaws.com'
            Action:
              - 'sts:AssumeRole'
      Path: '/'
      Policies:
        - PolicyName: LambdaAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: 'Allow'
                Action: 'lambda:*'
                Resource: !GetAtt QueryDynamoDB.Arn
